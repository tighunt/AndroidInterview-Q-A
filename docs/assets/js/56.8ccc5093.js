(window.webpackJsonp=window.webpackJsonp||[]).push([[56],{182:function(e,r,t){"use strict";t.r(r);var n=t(0),a=Object(n.a)({},function(){var e=this,r=e.$createElement,t=e._self._c||r;return t("div",{staticClass:"content"},[e._m(0),e._v(" "),e._m(1),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://www.jianshu.com/p/afbf3444db19",target:"_blank",rel:"noopener noreferrer"}},[e._v("HierarchyViewer"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"http://blog.csdn.net/u011240877/article/details/54347396",target:"_blank",rel:"noopener noreferrer"}},[e._v("TraceView"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"http://blog.csdn.net/hfreeman2008/article/details/53538155",target:"_blank",rel:"noopener noreferrer"}},[e._v("Systrace"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"http://gityuan.com/2016/01/17/systrace/",target:"_blank",rel:"noopener noreferrer"}},[e._v("性能工具Systrace"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/27331842",target:"_blank",rel:"noopener noreferrer"}},[e._v("手把手教你使用Systrace（一）"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/27535205",target:"_blank",rel:"noopener noreferrer"}},[e._v("手把手教你使用Systrace（二）——锁优化"),t("OutboundLink")],1)])]),e._v(" "),e._m(2),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"http://developer.51cto.com/art/201511/496263.htm",target:"_blank",rel:"noopener noreferrer"}},[e._v("Java 代码性能优化"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://www.cnblogs.com/jianzh5/p/6437315.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("JAVA线程池调优"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"http://blog.csdn.net/luofenghan/article/details/78596950",target:"_blank",rel:"noopener noreferrer"}},[e._v("Java多线程引发的性能问题以及调优策略"),t("OutboundLink")],1)])]),e._v(" "),e._m(3),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://tech.meituan.com/hertz.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("移动端性能监控方案Hertz"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"http://www.androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Android 性能优化必知必会"),t("OutboundLink")],1)])]),e._v(" "),e._m(4),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://blog.csdn.net/u012124438/article/details/74617649",target:"_blank",rel:"noopener noreferrer"}},[e._v("Android性能优化系列之电量优化"),t("OutboundLink")],1)]),e._v(" "),t("li",[t("a",{attrs:{href:"https://tech.meituan.com/Dianping_Shortvideo_Battery_TestCase.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("大众点评App的短视频耗电量优化实战"),t("OutboundLink")],1)])]),e._v(" "),e._m(5),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"http://chuansong.me/n/1365714451480",target:"_blank",rel:"noopener noreferrer"}},[e._v("腾讯TMQ团队移动App的网络优化：24小时流量优化到原来15%历程"),t("OutboundLink")],1)])]),e._v(" "),t("h4",{attrs:{id:"android性能优化典范-第1季"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#android性能优化典范-第1季","aria-hidden":"true"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"http://hukai.me/android-performance-patterns/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Android性能优化典范 - 第1季"),t("OutboundLink")],1)]),e._v(" "),e._m(6),e._v(" "),t("h4",{attrs:{id:"android性能优化典范-第2季"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#android性能优化典范-第2季","aria-hidden":"true"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"http://hukai.me/android-performance-patterns-season-2/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Android性能优化典范 - 第2季"),t("OutboundLink")],1)]),e._v(" "),e._m(7),e._v(" "),t("h4",{attrs:{id:"android性能优化典范-第3季"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#android性能优化典范-第3季","aria-hidden":"true"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"http://hukai.me/android-performance-patterns-season-3/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Android性能优化典范 - 第3季"),t("OutboundLink")],1)]),e._v(" "),e._m(8),e._v(" "),t("h4",{attrs:{id:"android性能优化典范-第4季"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#android性能优化典范-第4季","aria-hidden":"true"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"http://hukai.me/android-performance-patterns-season-4/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Android性能优化典范 - 第4季"),t("OutboundLink")],1)]),e._v(" "),e._m(9),e._v(" "),t("h4",{attrs:{id:"android性能优化典范-第5季"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#android性能优化典范-第5季","aria-hidden":"true"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"http://hukai.me/android-performance-patterns-season-5/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Android性能优化典范 - 第5季"),t("OutboundLink")],1)]),e._v(" "),e._m(10),e._v(" "),t("h4",{attrs:{id:"android性能优化典范-第6季"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#android性能优化典范-第6季","aria-hidden":"true"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"http://hukai.me/android-performance-patterns-season-6/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Android性能优化典范 - 第6季"),t("OutboundLink")],1)]),e._v(" "),e._m(11),e._v(" "),t("h4",{attrs:{id:"官方性能优化系列教程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#官方性能优化系列教程","aria-hidden":"true"}},[e._v("#")]),e._v(" "),t("a",{attrs:{href:"https://www.youtube.com/playlist?list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE",target:"_blank",rel:"noopener noreferrer"}},[e._v("官方性能优化系列教程"),t("OutboundLink")],1)])])},[function(){var e=this.$createElement,r=this._self._c||e;return r("h3",{attrs:{id:"性能优化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#性能优化","aria-hidden":"true"}},[this._v("#")]),this._v(" 性能优化")])},function(){var e=this.$createElement,r=this._self._c||e;return r("h4",{attrs:{id:"工具"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#工具","aria-hidden":"true"}},[this._v("#")]),this._v(" 工具")])},function(){var e=this.$createElement,r=this._self._c||e;return r("h3",{attrs:{id:"java-层面"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#java-层面","aria-hidden":"true"}},[this._v("#")]),this._v(" Java 层面")])},function(){var e=this.$createElement,r=this._self._c||e;return r("h3",{attrs:{id:"android"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#android","aria-hidden":"true"}},[this._v("#")]),this._v(" Android")])},function(){var e=this.$createElement,r=this._self._c||e;return r("p",[r("strong",[this._v("耗电")])])},function(){var e=this.$createElement,r=this._self._c||e;return r("p",[r("strong",[this._v("流量")])])},function(){var e=this,r=e.$createElement,t=e._self._c||r;return t("ol",[t("li",[t("strong",[e._v("Render Performance")]),e._v(" Android系统每隔16ms发出VSYNC信号，触发对UI进行渲染，如果每次渲染都成功，这样就能够达到流畅的画面所需要的60fps，为了能够实现60fps，这意味着程序的大多数操作都必须在16ms内完成。我们可以通过一些工具来定位问题，比如可以使用HierarchyViewer来查找Activity中的布局是否过于复杂，也可以使用手机设置里面的开发者选项，打开Show GPU Overdraw等选项进行观察。你还可以使用TraceView来观察CPU的执行情况，更加快捷的找到性能瓶颈。")]),e._v(" "),t("li",[t("strong",[e._v("Understanding Overdraw")]),e._v(" Overdraw(过度绘制)描述的是屏幕上的某个像素在同一帧的时间内被绘制了多次。在多层次的UI结构里面，如果不可见的UI也在做绘制的操作，这就会导致某些像素区域被绘制了多次。这就浪费大量的CPU以及GPU资源。Overdraw有时候是因为你的UI布局存在大量重叠的部分，还有的时候是因为非必须的重叠背景。例如某个Activity有一个背景，然后里面的Layout又有自己的背景，同时子View又分别有自己的背景。仅仅是通过移除非必须的背景图片，这就能够减少大量的红色Overdraw区域，增加蓝色区域的占比。这一措施能够显著提升程序性能。")]),e._v(" "),t("li",[t("strong",[e._v("Understanding VSYNC")]),e._v(" Refresh Rate：代表了屏幕在一秒内刷新屏幕的次数，这取决于硬件的固定参数，例如60Hz。Frame Rate：代表了GPU在一秒内绘制操作的帧数，例如30fps，60fps。通常来说，帧率超过刷新频率只是一种理想的状况，在超过60fps的情况下，GPU所产生的帧数据会因为等待VSYNC的刷新信息而被Hold住，这样能够保持每次刷新都有实际的新的数据可以显示。但是我们遇到更多的情况是帧率小于刷新频率。")]),e._v(" "),t("li",[t("strong",[e._v("Tool:Profile GPU Rendering")]),e._v(" 性能问题如此的麻烦，幸好我们可以有工具来进行调试。打开手机里面的开发者选项，选择Profile GPU Rendering，选中On screen as bars的选项。")]),e._v(" "),t("li",[t("strong",[e._v("Why 60fps?")]),e._v(" 我们通常都会提到60fps与16ms，可是知道为何会是以程序是否达到60fps来作为App性能的衡量标准吗？这是因为人眼与大脑之间的协作无法感知超过60fps的画面更新。开发app的性能目标就是保持60fps，这意味着每一帧你只有16ms=1000/60的时间来处理所有的任务。")]),e._v(" "),t("li",[t("strong",[e._v("Android, UI and the GPU")]),e._v(" 在Android里面那些由主题所提供的资源，例如Bitmaps，Drawables都是一起打包到统一的Texture纹理当中，然后再传递到GPU里面，这意味着每次你需要使用这些资源的时候，都是直接从纹理里面进行获取渲染的。当然随着UI组件的越来越丰富，有了更多演变的形态。例如显示图片的时候，需要先经过CPU的计算加载到内存中，然后传递给GPU进行渲染。文字的显示更加复杂，需要先经过CPU换算成纹理，然后再交给GPU进行渲染，回到CPU绘制单个字符的时候，再重新引用经过GPU渲染的内容。动画则是一个更加复杂的操作流程。为了能够使得App流畅，我们需要在每一帧16ms以内处理完所有的CPU与GPU计算，绘制，渲染等等操作。")]),e._v(" "),t("li",[t("strong",[e._v("Invalidations, Layouts, and Performance")]),e._v(" 任何时候View中的绘制内容发生变化时，都会重新执行创建DisplayList，渲染DisplayList，更新到屏幕上等一系列操作。这个流程的表现性能取决于你的View的复杂程度，View的状态变化以及渲染管道的执行性能。举个例子，假设某个Button的大小需要增大到目前的两倍，在增大Button大小之前，需要通过父View重新计算并摆放其他子View的位置。修改View的大小会触发整个HierarcyView的重新计算大小的操作。如果是修改View的位置则会触发HierarchView重新计算其他View的位置。如果布局很复杂，这就会很容易导致严重的性能问题。我们需要尽量减少Overdraw。")]),e._v(" "),t("li",[t("strong",[e._v("Overdraw, Cliprect, QuickReject")]),e._v(" 我们可以通过canvas.clipRect()来帮助系统识别那些可见的区域。这个方法可以指定一块矩形区域，只有在这个区域内才会被绘制，其他的区域会被忽视。这个API可以很好的帮助那些有多组重叠组件的自定义View来控制显示的区域。同时clipRect方法还可以帮助节约CPU与GPU资源，在clipRect区域之外的绘制指令都不会被执行，那些部分内容在矩形区域内的组件，仍然会得到绘制。")]),e._v(" "),t("li",[t("strong",[e._v("Memory Churn and performance")]),e._v(" 执行GC操作的时候，所有线程的任何操作都会需要暂停，等待GC操作完成之后，其他操作才能够继续运行。Memory Churn内存抖动，内存抖动是因为大量的对象被创建又在短时间内马上被释放。瞬间产生大量的对象会严重占用Young Generation的内存区域，当达到阀值，剩余空间不够的时候，也会触发GC。即使每次分配的对象占用了很少的内存，但是他们叠加在一起会增加Heap的压力，从而触发更多其他类型的GC。这个操作有可能会影响到帧率，并使得用户感知到性能问题。")]),e._v(" "),t("li",[t("strong",[e._v("Garbage Collection in Android")]),e._v(" 原始JVM中的GC机制在Android中得到了很大程度上的优化。Android里面是一个三级Generation的内存模型，最近分配的对象会存放在Young Generation区域，当这个对象在这个区域停留的时间达到一定程度，它会被移动到Old Generation，最后到Permanent Generation区域。如果不小心在最小的for循环单元里面执行了创建对象的操作，这将很容易引起GC并导致性能问题。通过Memory Monitor我们可以查看到内存的占用情况，每一次瞬间的内存降低都是因为此时发生了GC操作，如果在短时间内发生大量的内存上涨与降低的事件，这说明很有可能这里有性能问题。我们还可以通过Heap and Allocation Tracker工具来查看此时内存中分配的到底有哪些对象。")]),e._v(" "),t("li",[t("strong",[e._v("Performance Cost of Memory Leaks")]),e._v(" 内存泄漏指的是那些程序不再使用的对象无法被GC识别，这样就导致这个对象一直留在内存当中，占用了宝贵的内存空间。显然，这还使得每级Generation的内存区域可用空间变小，GC就会更容易被触发，从而引起性能问题。")]),e._v(" "),t("li",[t("strong",[e._v("Memory Performance")]),e._v(" 通常来说，Android对GC做了大量的优化操作，虽然执行GC操作的时候会暂停其他任务，可是大多数情况下，GC操作还是相对很安静并且高效的。但是如果我们对内存的使用不恰当，导致GC频繁执行，这样就会引起不小的性能问题。")]),e._v(" "),t("li",[t("strong",[e._v("Tool - Memory Monitor")]),e._v(" Android Studio中的Memory Monitor可以很好的帮助我们查看程序的内存使用情况。")]),e._v(" "),t("li",[t("strong",[e._v("Battery Performance")]),e._v(" 我们应该尽量减少唤醒屏幕的次数与持续的时间，使用WakeLock来处理唤醒的问题，能够正确执行唤醒操作并根据设定及时关闭操作进入睡眠状态。某些非必须马上执行的操作，例如上传歌曲，图片处理等，可以等到设备处于充电状态或者电量充足的时候才进行。触发网络请求的操作，每次都会保持无线信号持续一段时间，我们可以把零散的网络请求打包进行一次操作，避免过多的无线信号引起的电量消耗。关于网络请求引起无线信号的电量消耗")]),e._v(" "),t("li",[t("strong",[e._v("Understanding Battery Drain on Android")]),e._v(" 使用WakeLock或者JobScheduler唤醒设备处理定时的任务之后，一定要及时让设备回到初始状态。每次唤醒无线信号进行数据传递，都会消耗很多电量，它比WiFi等操作更加的耗电")]),e._v(" "),t("li",[t("strong",[e._v("Battery Drain and WakeLocks")]),e._v(" 这正是JobScheduler API所做的事情。它会根据当前的情况与任务，组合出理想的唤醒时间，例如等到正在充电或者连接到WiFi的时候，或者集中任务一起执行。我们可以通过这个API实现很多免费的调度算法。")])])},function(){var e=this,r=e.$createElement,t=e._self._c||r;return t("ol",[t("li",[t("strong",[e._v("Battery Drain and Networking")]),e._v(" 我们可以有针对性的把请求行为捆绑起来，延迟到某个时刻统一发起请求。这部分主要会涉及到Prefetch(预取)与Compressed(压缩)这两个技术。对于Prefetch的使用，我们需要预先判断用户在此次操作之后，后续零散的请求是否很有可能会马上被触发，可以把后面5分钟有可能会使用到的零散请求都一次集中执行完毕。对于Compressed的使用，在上传与下载数据之前，使用CPU对数据进行压缩与解压，可以很大程度上减少网络传输的时间。")]),e._v(" "),t("li",[t("strong",[e._v("Wear & Sensors")]),e._v(" 首先我们需要尽量使用Android平台提供的既有运动数据，而不是自己去实现监听采集数据，因为大多数Android Watch自身记录Sensor数据的行为是有经过做电量优化的。其次在Activity不需要监听某些Sensor数据的时候需要尽快释放监听注册。还有我们需要尽量控制更新的频率，仅仅在需要刷新显示数据的时候才触发获取最新数据的操作。另外我们可以针对Sensor的数据做批量处理，待数据累积一定次数或者某个程度的时候才更新到UI上。最后当Watch与Phone连接起来的时候，可以把某些复杂操作的事情交给Phone来执行，Watch只需要等待返回的结果。")]),e._v(" "),t("li",[t("strong",[e._v("Smooth Android Wear Animation")]),e._v(" 在Android里面一个相对操作比较繁重的事情是对Bitmap进行旋转，缩放，裁剪等等。例如在一个圆形的钟表图上，我们把时钟的指针抠出来当做单独的图片进行旋转会比旋转一张完整的圆形图的所形成的帧率要高56%。")]),e._v(" "),t("li",[t("strong",[e._v("Android Wear Data Batching")]),e._v(" 仅仅在真正需要刷新界面的时候才发出请求，尽量把计算复杂操作的任务交给Phone来处理，Phone仅仅在数据发生变化的时候才通知到Wear，把零碎的数据请求捆绑一起再进行操作。")]),e._v(" "),t("li",[t("strong",[e._v("Object Pools")]),e._v(" 使用对象池技术有很多好处，它可以避免内存抖动，提升性能，但是在使用的时候有一些内容是需要特别注意的。通常情况下，初始化的对象池里面都是空白的，当使用某个对象的时候先去对象池查询是否存在，如果不存在则创建这个对象然后加入对象池，但是我们也可以在程序刚启动的时候就事先为对象池填充一些即将要使用到的数据，这样可以在需要使用到这些对象的时候提供更快的首次加载速度，这种行为就叫做预分配。使用对象池也有不好的一面，程序员需要手动管理这些对象的分配与释放，所以我们需要慎重地使用这项技术，避免发生对象的内存泄漏。为了确保所有的对象能够正确被释放，我们需要保证加入对象池的对象和其他外部对象没有互相引用的关系。")]),e._v(" "),t("li",[t("strong",[e._v("To Index or Iterate?")]),e._v(" for index的方式有更好的效率，但是因为不同平台编译器优化各有差异，我们最好还是针对实际的方法做一下简单的测量比较好，拿到数据之后，再选择效率最高的那个方式。")]),e._v(" "),t("li",[t("strong",[e._v("The Magic of LRU Cache")]),e._v(" 使用LRU Cache能够显著提升应用的性能，可是也需要注意LRU Cache中被淘汰对象的回收，否者会引起严重的内存泄露。")]),e._v(" "),t("li",[t("strong",[e._v("Using LINT for Performance Tips")]),e._v(" Lint已经集成到Android Studio中了，我们可以手动去触发这个工具，点击工具栏的Analysis -> Inspect Code，触发之后，Lint会开始工作，并把结果输出到底部的工具栏，我们可以逐个查看原因并根据指示做相应的优化修改。")]),e._v(" "),t("li",[t("strong",[e._v("Hidden Cost of Transparency")]),e._v(" 通常来说，对于不透明的View，显示它只需要渲染一次即可，可是如果这个View设置了alpha值，会至少需要渲染两次。")]),e._v(" "),t("li",[t("strong",[e._v("Avoiding Allocations in onDraw()")]),e._v(" 首先onDraw()方法是执行在UI线程的，在UI线程尽量避免做任何可能影响到性能的操作。虽然分配内存的操作并不需要花费太多系统资源，但是这并不意味着是免费无代价的。设备有一定的刷新频率，导致View的onDraw方法会被频繁的调用，如果onDraw方法效率低下，在频繁刷新累积的效应下，效率低的问题会被扩大，然后会对性能有严重的影响。")]),e._v(" "),t("li",[t("strong",[e._v("Tool: Strict Mode")]),e._v(" Android提供了一个叫做Strict Mode的工具，我们可以通过手机设置里面的开发者选项，打开Strict Mode选项，如果程序存在潜在的隐患，屏幕就会闪现红色。我们也可以通过StrictMode API在代码层面做细化的跟踪，可以设置StrictMode监听那些潜在问题，出现问题时如何提醒开发者，可以对屏幕闪红色，也可以输出错误日志。")]),e._v(" "),t("li",[t("strong",[e._v("Custom Views and Performance")]),e._v(" Useless calls to onDraw()：我们知道调用View.invalidate()会触发View的重绘，有两个原则需要遵守，第1个是仅仅在View的内容发生改变的时候才去触发invalidate方法，第2个是尽量使用ClipRect等方法来提高绘制的性能。Useless pixels：减少绘制时不必要的绘制元素，对于那些不可见的元素，我们需要尽量避免重绘。Wasted CPU cycles：对于不在屏幕上的元素，可以使用Canvas.quickReject把他们给剔除，避免浪费CPU资源。另外尽量使用GPU来进行UI的渲染，这样能够极大的提高程序的整体表现性能。")]),e._v(" "),t("li",[t("strong",[e._v("Batching Background Work Until Later")]),e._v("\n1.AlarmManager 使用AlarmManager设置定时任务，可以选择精确的间隔时间，也可以选择非精确时间作为参数。除非程序有很强烈的需要使用精确的定时唤醒，否者一定要避免使用他，我们应该尽量使用非精确的方式。2.SyncAdapter 我们可以使用SyncAdapter为应用添加设置账户，这样在手机设置的账户列表里面可以找到我们的应用。这种方式功能更多，但是实现起来比较复杂。我们可以从这里看到官方的培训课程：http://developer.android.com/training/sync-adapters/index.html 3.JobSchedulor 这是最简单高效的方法，我们可以设置任务延迟的间隔，执行条件，还可以增加重试机制。")]),e._v(" "),t("li",[t("strong",[e._v("Smaller Pixel Formats")]),e._v(" Android的Heap空间是不会自动做兼容压缩的，意思就是如果Heap空间中的图片被收回之后，这块区域并不会和其他已经回收过的区域做重新排序合并处理，那么当一个更大的图片需要放到heap之前，很可能找不到那么大的连续空闲区域，那么就会触发GC，使得heap腾出一块足以放下这张图片的空闲区域，如果无法腾出，就会发生OOM。")]),e._v(" "),t("li",[t("strong",[e._v("Smaller PNG Files")]),e._v(" 尽量减少PNG图片的大小是Android里面很重要的一条规范。相比起JPEG，PNG能够提供更加清晰无损的图片，但是PNG格式的图片会更大，占用更多的磁盘空间。到底是使用PNG还是JPEG，需要设计师仔细衡量，对于那些使用JPEG就可以达到视觉效果的，可以考虑采用JPEG即可。")]),e._v(" "),t("li",[t("strong",[e._v("Pre-scaling Bitmaps")]),e._v(" 对bitmap做缩放，这也是Android里面最遇到的问题。对bitmap做缩放的意义很明显，提示显示性能，避免分配不必要的内存。Android提供了现成的bitmap缩放的API，叫做createScaledBitmap()")]),e._v(" "),t("li",[t("strong",[e._v("Re-using Bitmaps")]),e._v(" 使用inBitmap属性可以告知Bitmap解码器去尝试使用已经存在的内存区域，新解码的bitmap会尝试去使用之前那张bitmap在heap中所占据的pixel data内存区域，而不是去问内存重新申请一块区域来存放bitmap。利用这种特性，即使是上千张的图片，也只会仅仅只需要占用屏幕所能够显示的图片数量的内存大小。")]),e._v(" "),t("li",[t("strong",[e._v("The Performance Lifecycle")]),e._v(" Gather：收集数据，Insight：分析数据，Action：解决问题")])])},function(){var e=this,r=e.$createElement,t=e._self._c||r;return t("ol",[t("li",[t("strong",[e._v("Fun with ArrayMaps")]),e._v(" 为了解决HashMap更占内存的弊端，Android提供了内存效率更高的ArrayMap。它内部使用两个数组进行工作，其中一个数组记录key hash过后的顺序列表，另外一个数组按key的顺序记录Key-Value值")]),e._v(" "),t("li",[t("strong",[e._v("Beware Autoboxing")]),e._v(" 有时候性能问题也可能是因为那些不起眼的小细节引起的，例如在代码中不经意的“自动装箱”。我们知道基础数据类型的大小：boolean(8 bits), int(32 bits), float(32 bits)，long(64 bits)，为了能够让这些基础数据类型在大多数Java容器中运作，会需要做一个autoboxing的操作，转换成Boolean，Integer，Float等对象")]),e._v(" "),t("li",[t("strong",[e._v("SparseArray Family Ties")]),e._v(" 为了避免HashMap的autoboxing行为，Android系统提供了SparseBoolMap，SparseIntMap，SparseLongMap，LongSparseMap等容器。")]),e._v(" "),t("li",[t("strong",[e._v("The price of ENUMs")]),e._v(" Android官方强烈建议不要在Android程序里面使用到enum。")]),e._v(" "),t("li",[t("strong",[e._v("Trimming and Sharing Memory")]),e._v(" Android系统提供了一些回调来通知应用的内存使用情况，通常来说，当所有的background应用都被kill掉的时候，forground应用会收到onLowMemory()的回调。在这种情况下，需要尽快释放当前应用的非必须内存资源，从而确保系统能够稳定继续运行。Android系统还提供了onTrimMemory()的回调，当系统内存达到某些条件的时候，所有正在运行的应用都会收到这个回调")]),e._v(" "),t("li",[t("strong",[e._v("DO NOT LEAK VIEWS")]),e._v(" 避免使用异步回调,避免使用Static对象,避免把View添加到没有清除机制的容器里面")]),e._v(" "),t("li",[t("strong",[e._v("Location & Battery Drain")]),e._v(" 其中存在的一个优化点是，我们可以通过判断返回的位置信息是否相同，从而决定设置下次的更新间隔是否增加一倍，通过这种方式可以减少电量的消耗")]),e._v(" "),t("li",[t("strong",[e._v("Double Layout Taxation")]),e._v(" 布局中的任何一个View一旦发生一些属性变化，都可能引起很大的连锁反应。例如某个button的大小突然增加一倍，有可能会导致兄弟视图的位置变化，也有可能导致父视图的大小发生改变。当大量的layout()操作被频繁调用执行的时候，就很可能引起丢帧的现象。")]),e._v(" "),t("li",[t("strong",[e._v("Network Performance 101")]),e._v(" 减少移动网络被激活的时间与次数,压缩传输数据")]),e._v(" "),t("li",[t("strong",[e._v("Effective Network Batching")]),e._v(" 发起网络请求与接收返回数据都是比较耗电的，在网络硬件模块被激活之后，会继续保持几十秒的电量消耗，直到没有新的网络操作行为之后，才会进入休眠状态。前面一个段落介绍了使用Batching的技术来捆绑网络请求，从而达到减少网络请求的频率。那么如何实现Batching技术呢？通常来说，我们可以会把那些发出的网络请求，先暂存到一个PendingQueue里面，等到条件合适的时候再触发Queue里面的网络请求。")]),e._v(" "),t("li",[t("strong",[e._v("Optimizing Network Request Frequencies")]),e._v(" 前面的段落已经提到了应该减少网络请求的频率，这是为了减少电量的消耗。我们可以使用Batching，Prefetching的技术来避免频繁的网络请求。Google提供了GCMNetworkManager来帮助开发者实现那些功能，通过提供的API，我们可以选择在接入WiFi，开始充电，等待移动网络被激活等条件下再次激活网络请求。")]),e._v(" "),t("li",[t("strong",[e._v("Effective Prefetching")]),e._v(" 类似上面的情况会频繁触发网络请求，但是如果我们能够预先请求后续可能会使用到网络资源，避免频繁的触发网络请求，这样就能够显著的减少电量的消耗。可是预先获取多少数据量是很值得考量的，因为如果预取数据量偏少，就起不到减少频繁请求的作用，可是如果预取数据过多，就会造成资源的浪费。")])])},function(){var e=this,r=e.$createElement,t=e._self._c||r;return t("ol",[t("li",[t("strong",[e._v("Cachematters for networking")]),e._v(" 想要使得Android系统上的网络访问操作更加的高效就必须做好网络数据的缓存。这是提高网络访问性能最基础的步骤之一。从手机的缓存中直接读取数据肯定比从网络上获取数据要更加的便捷高效，特别是对于那些会被频繁访问到的数据，需要把这些数据缓存到设备上，以便更加快速的进行访问。")]),e._v(" "),t("li",[t("strong",[e._v("Optimizing Network Request Frequencies")]),e._v(" 首先我们要对网络行为进行分类，区分需要立即更新数据的行为和其他可以进行延迟的更新行为，为不同的场景进行差异化处理。其次要避免客户端对服务器的轮询操作，这样会浪费很多的电量与带宽流量。解决这个问题，我们可以使用Google Cloud Message来对更新的数据进行推送。然后在某些必须做同步的场景下，需要避免使用固定的间隔频率来进行更新操作，我们应该在返回的数据无更新的时候，使用双倍的间隔时间来进行下一次同步。最后更进一步，我们还可以通过判断当前设备的状态来决定同步的频率，例如判断设备处于休眠，运动等不同的状态设计各自不同时间间隔的同步频率。")]),e._v(" "),t("li",[t("strong",[e._v("Effective Prefetching")]),e._v(" 到底预取多少才比较合适呢？一个比较普适的规则是，在3G网络下可以预取1-5Mb的数据量，或者是按照提前预期后续1-2分钟的数据作为基线标准。在实际的操作当中，我们还需要考虑当前的网络速度来决定预取的数据量，例如在同样的时间下，4G网络可以获取到12张图片的数据，而2G网络则只能拿到3张图片的数据。所以，我们还需要把当前的网络环境情况添加到设计预取数据量的策略当中去。判断当前设备的状态与网络情况，可以使用前面提到过的GCMNetworkManager。")]),e._v(" "),t("li",[t("strong",[e._v("Adapting to Latency")]),e._v(" 一个典型的网络操作行为，通常包含以下几个步骤：首先手机端发起网络请求，到达网络服务运营商的基站，再转移到服务提供者的服务器上，经过解码之后，接着访问本地的存储数据库，获取到数据之后，进行编码，最后按照原来传递的路径逐层返回。常来说，我们可以把网络请求延迟划分为三档：例如把网络延迟小于60ms的划分为GOOD，大于220ms的划分为BAD，介于两者之间的划分为OK（这里的60ms，220ms会需要根据不同的场景提前进行预算推测）。")]),e._v(" "),t("li",[t("strong",[e._v("Minimizing Asset Payload")]),e._v(" 为了能够减小网络传输的数据量，我们需要对传输的数据做压缩的处理，这样能够提高网络操作的性能。首先需要做的是减少图片的大小，其次需要做的是减少序列化数据的大小。")]),e._v(" "),t("li",[t("strong",[e._v("Service Performance Patterns")]),e._v(" Service是Android程序里面最常用的基础组件之一，但是使用Service很容易引起电量的过度消耗以及系统资源的未及时释放。避免错误的使用Service，例如我们不应该使用Service来监听某些事件的变化，不应该搞一个Service在后台对服务器不断的进行轮询(应该使用Google Cloud Messaging)。如果已经事先知道Service里面的任务应该执行在后台线程(非默认的主线程)的时候，我们应该使用IntentService或者结合HanderThread，AsycnTask Loader实现的Service。")]),e._v(" "),t("li",[t("strong",[e._v("Removing unused code")]),e._v(" Android为我们提供了Proguard的工具来帮助应用程序对代码进行瘦身，优化，混淆的处理。它会帮助移除那些没有使用到的代码，还可以对类名，方法名进行混淆处理以避免程序被反编译。")]),e._v(" "),t("li",[t("strong",[e._v("Removing unused resources")]),e._v(" 所幸的是，我们可以使用Gradle来帮助我们分析代码，分析引用的资源，对于那些没有被引用到的资源，会在编译阶段被排除在APK安装包之外，要实现这个功能，对我们来说仅仅只需要在build.gradle文件中配置shrinkResource为true就好了")]),e._v(" "),t("li",[t("strong",[e._v("Perf Theory: Caching")]),e._v(" 当我们讨论性能优化的时候，缓存是最常见最有效的策略之一。无论是为了提高CPU的计算速度还是提高数据的访问速度，在绝大多数的场景下，我们都会使用到缓存。")]),e._v(" "),t("li",[t("strong",[e._v("Perf Theory: Approximation(近似法)")]),e._v(" 例如使用一张比较接近实际大小的图片来替代原图，换取更快的加载速度。所以对于那些对计算结果要求不需要十分精确的场景，我们可以使用近似法则来提高程序的性能。")]),e._v(" "),t("li",[t("strong",[e._v("Perf Theory: Culling(遴选，挑选)")]),e._v(" 一个提高性能的方法是逐步对数据进行过滤筛选，减小搜索的数据集，以此提高程序的执行性能。例如我们需要搜索到居住在某个地方，年龄是多少，符合某些特定条件的候选人，就可以通过逐层过滤筛选的方式来提高后续搜索的执行效率。")]),e._v(" "),t("li",[t("strong",[e._v("Perf Theory: Threading")]),e._v(" 使用多线程并发处理任务，从某种程度上可以快速提高程序的执行性能。对于Android程序来说，主线程通常也成为UI线程，需要处理UI的渲染，响应用户的操作等等。")]),e._v(" "),t("li",[t("strong",[e._v("Perf Theory: Batching")]),e._v(" 网络请求的批量执行是另外一个比较适合说明batching使用场景的例子，因为每次发起网络请求都相对来说比较耗时耗电，如果能够做到批量一起执行，可以大大的减少电量的消耗。")]),e._v(" "),t("li",[t("strong",[e._v("Serialization performance")]),e._v(" 数据序列化的行为可能发生在数据传递过程中的任何阶段，例如网络传输，不同进程间数据传递，不同类之间的参数传递，把数据存储到磁盘上等等。通常情况下，我们会把那些需要序列化的类实现Serializable接口(如下图所示)，但是这种传统的做法效率不高，实施的过程会消耗更多的内存。但是我们如果使用GSON库来处理这个序列化的问题，不仅仅执行速度更快，内存的使用效率也更高。Android的XML布局文件会在编译的阶段被转换成更加复杂的格式，具备更加高效的执行性能与更高的内存使用效率。")]),e._v(" "),t("li",[t("strong",[e._v("Smaller Serialized Data")]),e._v(" 数据呈现的顺序以及结构会对序列化之后的空间产生不小的影响。")]),e._v(" "),t("li",[t("strong",[e._v("Caching UI data")]),e._v(" 缓存UI界面上的数据，可以采用方案有存储到文件系统，Preference，SQLite等等，做了缓存之后，这样就可以在请求数据返回结果之前，呈现给用户旧的数据，而不是使用正在加载的方式让用户什么数据都看不到，当然在请求网络最新数据的过程中，需要有正在刷新的提示。至于到底选择哪个方案来对数据进行缓存，就需要根据具体情况来做选择了。")]),e._v(" "),t("li",[t("strong",[e._v("CPU Frequency Scaling")]),e._v(" 调节CPU的频率会执行的性能产生较大的影响，为了最大化的延长设备的续航时间，系统会动态调整CPU的频率，频率越高执行代码的速度自然就越快。我们可以使用Systrace工具来导出CPU的执行情况，以便帮助定位性能问题。")])])},function(){var e=this,r=e.$createElement,t=e._self._c||r;return t("ol",[t("li",[t("strong",[e._v("Threading Performance")]),e._v(" AsyncTask: 为UI线程与工作线程之间进行快速的切换提供一种简单便捷的机制。适用于当下立即需要启动，但是异步执行的生命周期短暂的使用场景。HandlerThread: 为某些回调方法或者等待某些任务的执行设置一个专属的线程，并提供线程任务的调度机制。ThreadPool: 把任务分解成不同的单元，分发到各个不同的线程上，进行同时并发处理。IntentService: 适合于执行由UI触发的后台Service任务，并可以把后台任务执行的情况通过一定的机制反馈给UI。")]),e._v(" "),t("li",[t("strong",[e._v("Understanding Android Threading")]),e._v(" 通常来说，一个线程需要经历三个生命阶段：开始，执行，结束。线程会在任务执行完毕之后结束，那么为了确保线程的存活，我们会在执行阶段给线程赋予不同的任务，然后在里面添加退出的条件从而确保任务能够执行完毕后退出。")]),e._v(" "),t("li",[t("strong",[e._v("Memory & Threading")]),e._v(" 不要在任何非UI线程里面去持有UI对象的引用。系统为了确保所有的UI对象都只会被UI线程所进行创建，更新，销毁的操作，特地设计了对应的工作机制(当Activity被销毁的时候，由该Activity所触发的非UI线程都将无法对UI对象进行操作，否者就会抛出程序执行异常的错误)来防止UI对象被错误的使用。")]),e._v(" "),t("li",[t("strong",[e._v("Good AsyncTask Hunting")]),e._v(" AsyncTask虽然提供了一种简单便捷的异步机制，但是我们还是很有必要特别关注到他的缺点，避免出现因为使用错误而导致的严重系统性能问题。")]),e._v(" "),t("li",[t("strong",[e._v("Getting a HandlerThread")]),e._v(" HandlerThread比较合适处理那些在工作线程执行，需要花费时间偏长的任务。我们只需要把任务发送给HandlerThread，然后就只需要等待任务执行结束的时候通知返回到主线程就好了。另外很重要的一点是，一旦我们使用了HandlerThread，需要特别注意给HandlerThread设置不同的线程优先级，CPU会根据设置的不同线程优先级对所有的线程进行调度优化。")]),e._v(" "),t("li",[t("strong",[e._v("Swimming in Threadpools")]),e._v(" 线程池适合用在把任务进行分解，并发进行执行的场景。通常来说，系统里面会针对不同的任务设置一个单独的守护线程用来专门处理这项任务。")]),e._v(" "),t("li",[t("strong",[e._v("The Zen of IntentService")]),e._v(" 默认的Service是执行在主线程的，可是通常情况下，这很容易影响到程序的绘制性能(抢占了主线程的资源)。除了前面介绍过的AsyncTask与HandlerThread，我们还可以选择使用IntentService来实现异步操作。IntentService继承自普通Service同时又在内部创建了一个HandlerThread，在onHandlerIntent()的回调里面处理扔到IntentService的任务。所以IntentService就不仅仅具备了异步线程的特性，还同时保留了Service不受主页面生命周期影响的特点。")]),e._v(" "),t("li",[t("strong",[e._v("Threading and Loaders")]),e._v(" 当启动工作线程的Activity被销毁的时候，我们应该做点什么呢？为了方便的控制工作线程的启动与结束，Android为我们引入了Loader来解决这个问题。我们知道Activity有可能因为用户的主动切换而频繁的被创建与销毁，也有可能是因为类似屏幕发生旋转等被动原因而销毁再重建。在Activity不停的创建与销毁的过程当中，很有可能因为工作线程持有Activity的View而导致内存泄漏(因为工作线程很可能持有View的强引用，另外工作线程的生命周期还无法保证和Activity的生命周期一致，这样就容易发生内存泄漏了)。除了可能引起内存泄漏之外，在Activity被销毁之后，工作线程还继续更新视图是没有意义的，因为此时视图已经不在界面上显示了。")]),e._v(" "),t("li",[t("strong",[e._v("The Importance of Thread Priority")]),e._v(" 在Android系统里面，我们可以通过android.os.Process.setThreadPriority(int)设置线程的优先级，参数范围从-20到24，数值越小优先级越高。Android系统还为我们提供了以下的一些预设值，我们可以通过给不同的工作线程设置不同数值的优先级来达到更细粒度的控制。")]),e._v(" "),t("li",[t("strong",[e._v("Profile GPU Rendering : M Update")]),e._v(" 从Android M系统开始，系统更新了GPU Profiling的工具来帮助我们定位UI的渲染性能问题。早期的CPU Profiling工具只能粗略的显示出Process，Execute，Update三大步骤的时间耗费情况。")])])},function(){var e=this,r=e.$createElement,t=e._self._c||r;return t("ol",[t("li",[t("strong",[e._v("App Launch time 101")]),e._v(" 提高程序的启动速度意义重大，很显然，启动时间越短，用户才越有耐心等待打开这个APP进行使用，反之启动时间越长，用户则越有可能来不及等到APP打开就已经切换到其他APP了。程序启动过程中的那些复杂错误的操作很可能导致严重的性能问题。Android系统会根据用户的操作行为调整程序的显示策略，用来提高程序的显示性能。例如，一旦用户点击桌面图标，Android系统会立即显示一个启动窗口，这个窗口会一直保持显示直到画面中的元素成功加载并绘制完第一帧。这种行为常见于程序的冷启动，或者程序的热启动场景（程序从后台被唤起或者从其他APP界面切换回来）。那么关键的问题是，用户很可能会因为从启动窗口到显示画面的过程耗时过长而感到厌烦，从而导致用户没有来得及等程序启动完毕就切换到其他APP了。更严重的是，如果启动时间过长，可能导致程序出现ANR。我们应该避免出现这两种糟糕的情况。")]),e._v(" "),t("li",[t("strong",[e._v("App Launch Time & Activity Creation")]),e._v(" 优化布局耗时：一个布局层级越深，里面包含需要加载的元素越多，就会耗费更多的初始化时间。关于布局性能的优化，这里就不展开描述了！异步延迟加载：一开始只初始化最需要的布局，异步加载图片，非立即需要的组件可以做延迟加载。")]),e._v(" "),t("li",[t("strong",[e._v("App Launch Time & Bloated Application Objects")]),e._v(" 优化这些问题的解决方案是做延迟加载，可以在application里面做延迟加载，也可以把一些初始化的操作延迟到组件真正被调用到的时候再做加载。")]),e._v(" "),t("li",[t("strong",[e._v("App Launch Time & Theme Launch Screens")]),e._v(" 目前大多数开发者都会通过设置启动窗口主题的方式来替换系统默认的启动窗口，通过这种方式只是使用『障眼法』弱化了用户对启动时间的感知，但本质上并没有对启动速度做什么优化。也有些APP通过关闭启动窗口属性android:windowDisablePreview的方式来直接移除系统默认的启动窗口，但是这样的弊端是用户从点击桌面图标到真的看到实际页面的这段时间当中，画面没有任何变化，这样的用户体验是十分糟糕的！")]),e._v(" "),t("li",[t("strong",[e._v("Smaller APKs: A Checklist")]),e._v(" 1）确保在build.gradle文件中开启了minifEnabled与shrinkResources的属性，这两个属性可以帮助移除那些在程序中使用不到的代码与资源，帮助减少APP的安装包大小。2）有选择性的提供对应分辨率的图片资源，系统会自动匹配最合适分辨率的图片并执行拉伸或者压缩的处理。3）在符合条件的情况下，使用Vertor Drawable替代传统的PNG/JPEG图片，能够极大的减少图片资源的大小。传统模式下，针对不同dpi的手机都需要提供一套PNG/JPEG的图片，而如果使用Vector Drawable的话，只需要一个XML文件即可。4）尽量复用已经存在的资源图片，使用代码的方式对已有的资源进行复用 5）开启MinifEnabled，Proguard。打开这些编译属性之后，程序在打包的时候就不会把没有引用到的代码编译进来，以此达到减少安装包大小的目的。6）注意因为编译行为额外产生的方法数，例如类似Enum，Protocal Buffer可能导致方法数与类的个数增加。7）部分引入到工程中的jar类库可能并不是专门针对移动端APP而设计的，他们最开始可能是运用在PC或者Server上的。使用这些类库不仅仅额外增加了包的大小，还增加了编译时间。单纯依靠Proguard可能无法完全移除那些使用不到的方法，最佳的方式是使用一些更加轻量化，专门为Android APP设计的jar类库。")]),e._v(" "),t("li",[t("strong",[e._v("VectorDrawable for smaller APKs")]),e._v(" 针对不同的分辨率提供多张精度的图片会额外增加APK的大小，针对这个问题的解决方案是考虑使用VectorDrawable，它仅仅只需要一个文件，能够动态生成对应分辨率的图片。")])])}],!1,null,null,null);a.options.__file="性能优化.md";r.default=a.exports}}]);